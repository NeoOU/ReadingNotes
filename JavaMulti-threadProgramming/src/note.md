# 第一章 java多线程技能
- 进程是受操作系统管理的基本运行单元
- 线程是在进程中独立运行的子任务 
- 使用多线程也就是在使用异步
- 一个进程在运行时至少有一个线程在运行
- 线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法
- 自定义线程类中的实例变量，对其他线程可以有**共享**和**不共享**之分。共享数据可能出现非线程安全问题（数据同步问题）
- currentThread()返回代码块正被哪个线程调用的信息
- isAlive()方法，当线程进入准备好状态之后和run代码块在被执行完之前返回true(处于准备开始运行和正在运行的状态)
- sleep()方法，让当前正在执行的线程休眠。这个“正在执行的线程”是指this.currentThread()返回的线程
- yield()方法，放弃当前的CPU资源，让给其他任务去占用CPU执行时间
- java中线程分为两种：一种是用户线程，一种是守护线程（Daemon）。当进程中没有非守护线程了，刚守护线程自动销毁。典型的就是垃圾回收线程

# 第二章 对象及变量的并发访问
- “非线程安全”问题存在于“实例变量”中，如果是方法内部的私有变量，则不存在“非线程安全”问题。
- 关键字synchronized获取的是锁都是对象锁。只有是同一个对象，才能实现同步。如果是不同的对象，则会有多个不同的对象锁，锁住的也是各自不同的对象 ，也就不能实现同步。
- 脏读一定是出现在操作实例变量的情况下，这就是不同纯种“争抢”实例变量的结果。
- synchronized锁重入，当线程拿到一个类的锁后，在synchronied方法/块里调用本类的其他synchroized方法/块时，永远可以得到锁。不可重入的话就会造成死锁
- 可重入锁也支持在父子继承的环境中，子类完成可以通过可重入锁机制调用父类的同步方法。
- Class锁可以对类的所有对象实例起作用
- volatile关键字的作用是强制从**公共堆栈**中取得变量的值，而不是从线程**私有数据栈**中取得变量的值
- 使用volatile增加了实例变量在多个线程之间的可见性。但其最致命的缺点是不支持原子性
- 线程的安全包含原子性（同步性）和可见性两方面，java的同步机制都是围绕这两个方面来确保线程安全的
- 下图演示了volatile出现非线程安全的原因：</br>![变量在内存中的工作过程](./变量在内存中的工作过程.png)
 - read和load阶段：从主内存复制变量到当前线程工作内存;
 - use和assign阶段：执行代码，改变共享变量值
 - store和write阶段：用工作内存数据刷新主内存对应变量的值
 
 > 对于用volatile修饰的变量，JVM虚拟机只是保证从主内在加载到线程工作内在中的值是最新的，</br>例如线程1和线程2在进行read和load的操作中，发现主内存中count值都是5，那么都会加载这个最新值。


- ~~只要类中有synchronized方法和代码块，不管synchronized的对象是不是本类，这个类的实例变量就都是可见性的？~~ </br>synchronized可以保证进入同步方法或代码块的每个线程，能看到在锁保护之前，所有的修改效果。

# 第三章 线程间的通信
- 方法wait()的作用是使当前执行代码的线程进行等待。wait()方法是Object类的方法，该方法用来将当前线程置入“预执行队列”中，并在wait()所在的代码行处停止执行，直到接到通知或被中断为止。
- 在调用wait()方法之前，线程必须获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait()方法，在执行wait方法后，当前线程释放锁。
- 方法notify()也要在同步方法或同步块是调用，即在调用前，线程也必须获得该对象的对象级别锁。
- notify()方法用来通知那些可能等待该对象的对象锁的其他线程，如果存在多个线程等待，则由线程规划器随机挑选其中一个呈wait状态的线程，对其发出通知notify，并使他等待获取该对象的对象锁。
- 在执行notify()方法后，当前线程不会马上释放该对象锁，呈wait状态的线程也不能马上获取该对象锁，要等到执行notify()方法的线程将程序执行完，当前线程才会释放锁，呈wait状态的线程才可以获取该对象锁。
- wait线程运行完毕之后，它会释放掉该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到对象的通知，还会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll.
- wait()方法可以使调用该方法的线程释放共享资源的锁，然后从运行状态退出，进入等待队列，直到被再次唤醒。
- notify()方法可以随便唤醒等待队列中等待同一共享资源的“一个”线程，并使该线程退出等待队列，进入可运行状态，也就是notify()方法仅通知“一个”线程。
- notifyAll()方法可以使所在正在等待队列中等待同一共享资源的“全部”线程从等待状态退出，进入可运行状态。此时，优先级最高的那个线程最先执行，但也有可能是随机执行，这取决于JVM虚拟机的实现。
- 每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程。一个线程被唤醒后，才会进入就绪队列，等待CPU的调度；反之，一个线程被wait、sleep、suspend等后，就会进入阻塞队列，等待下一次被唤醒。
- 线程状态转换示意图如下：</br>![线程状态切换](./线程状态切换.jpg)
 - 新创建一个线程对象后，再调用它的start()方法，系统会为此线程分配CPU资源，使其处于Runnable（可运行）状态，这是一个准备运行的阶段。如果线程抢到CPU资源，就处于Running（运行）状态。
 - Runnable和Running状态可相互切换，因为有可能线程运行一段时间后，在其他高优先级的线程抢占了CPU资源，这时此线程就从Running状态变成Runnable状态。
  > 线程进入Runnable状态大体分为如下5种情况：
  > 1. 调用sleep()方法后经过的时间超过了指定的休眠时间；
  > 2. 线程调用的阻塞IO已经返回，阻塞方法执行完毕；
  > 3. 线程成功地获得了试图同步的监视器；
  > 4. 线程正在等待某个通知，其他线程发出了通知；
  > 5. 处于挂起状态的线程调用了一个resume恢复方法。 
  
 - Blocked是阻塞的意思，例如遇到一个阻塞IO操作，此时CPU处于空闲状态，可能会转而把CPU时间片分配给其他线程，这时也可以称为“暂时”状态。Blocked状态结束后，进入Runnabe状态，等待系统重新分配资源。
  > 出现阻塞的情况大体分为以下5种：
  > 1. 线程调用sleep方法，主动放弃占用的CPU资源；
  > 2. 线程调用了阻塞式IO方法，在该方法返回前，该线程被阻塞；
  > 3. 线程试图获得一个同步监视器，但该同步监视器正在被其他线程所持有；
  > 4. 线程等待某个通知；
  > 5. 程序调用了suspend方法将该线程挂起。
    
 - run()方法运行结束后进入销毁阶段，整个线程执行完毕。
 
- wait(long)方法的功能是等待某一时间内是否有线程对锁进行唤醒，如果超过这个时间则自动唤醒。
- 管道流（pipeStream）用于在不同间直接传送数据。通过使用管道流，不须借助于类似临时文件之类的东西--PipedInputStream和PipedOutputStream、PipedReader和PipedWriter
- inputStream.connect(outputStream)或outputStream.connect(inputStream)使两个Stream之间产生通信链接。
- 如果读取线程启动后，没有数据被写入，那么线程会被阻塞在in.read(byteArray)代码中，直到有数据被写入，才会继续运行。
- 如果主线程想等待子线程执行完成之后再结束，就要用join()方法。join()方法的作用是等待线程对象销毁。
- join()方法具有使线程排队运行的作用，有些类似同步运行的效果。join与synchronized的区别是：join在内部使用wait()方法进行等待，而synchronized关键字使用的是是“对象监视器”原理做为同步
- 主线程A在等待子线程B销毁时（调用了B.join()），如果等待过程中A被打断，A会抛出异常，但异常与B无关，B会继续运行至结束。
- join(time)调用的是wait(time)，所以join(time)会释放线程对象锁，在wait的时间消逝完后，重新竞争对象锁，拿到锁后再又又以把join(time)方法执行完
- ThreadLocal类：每个线程绑定自己的值

# 第四章 Lock的使用
- ReentrantReadWriteLock类，读写锁表示有两个锁，一个是读操作相关的锁，也称共享锁；另一个是写操作相关的锁，也叫排他锁。也就是多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥。
- ReentrantReadWriteLock类，“读写”、“写读”和“写写”都是互斥的；而“读读”是异步的，非互斥的。

# 第六章  单例模式与多线程
- 实例单例模式的方法有：立即加载（饿汉）模式、延迟加载（懒汉）模式、静态内部类模式、静态代码块模式、枚举模式
- 有效解决延迟加载（懒汉模式）下单例模式的非线程安全问题是使用DCL（double-check locking）双检查机制
 ``` java
     public class MyObject {
     
        private volatile static MyObject myObject;
     
        private MyObject() {
        }
     
        // 使用双检测机制来解决问题
        // 即保证了不需要同步代码的异步
        // 又保证了单例的效果
        public static MyObject getInstance() {
            try {
                if (myObject != null) {
                } else {
                    // 模拟在创建对象之前做一些准备性的工作
                    Thread.sleep(3000);
                    synchronized (MyObject.class) {
                        if (myObject == null) {
                            myObject = new MyObject();
                        }
                    }
                }
            } catch (InterruptedException e) {  
                e.printStackTrace();
            }
            return myObject;
        }
        // 此版本的代码称为：
        // 双重检查Double-Check Locking
     
     }
 
  ```
 
 - 在单例反序列化时，解决反序列化得到的对象是一个新对象，而不是原来的实例的问题：
  ```
  	protected Object readResolve() throws ObjectStreamException {
  		System.out.println("调用了readResolve方法！");
  		return MyObjectHandler.myObject;
  	}
  ```
  
  # 第七章 拾遗增补
  - 线程组，一级关联：父对象中有子对象，但并不创建子孙对象。多级关联：父对象中有子对象，子对象中再创建子对象，也就出现子孙对象的效果。