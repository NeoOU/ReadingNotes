#  策略模式（strategy pattern）
1. 概述：策略模式定义了一系列的算法，并将每一个算法封装起来，让它们之间可以相互替换。策略模式让算法的变化独立于使用它的客户。
2. 设计原则：
    1. 把会变化的部分取出并封装起来，好让其他部分不受到影响
    2. 针对接口编程，而不是针对实现编程
        1. 一个接口代表一个行为，行为的每个实现（暂时命名为行为类）都实现这个接口。也就是**接口的功能在行为类中实现**。
        2. 真正需要实现功能的类不实现接口（暂时命名为功能类），功能类要实现功能时，把功能的实现委托给行为类。
        3. 在功能类或其父类中，声明接口为变量。运行时将行为类指向接口。功能类在功能实现方法中，调用接口的方法。也就是**多态地调用行为类的方法**
    3. 多用组合少用继承。
        1. “有一个”比“是一个”更好。对象有一个行为，便可以将这个行为委托给行为类处理
        2. 功能类和行为类结合起来使用就是“组合”。与继承不同的是，功能类的功能不是继承而来的，而是与适当的行为类组合而来的。
3. 功效：
    1. 运行时设定行为
    2. 行为类可以轻易地扩充和改变

# 观察者模式（observer pattern）
1. 概述：观察者模式定义了对象之间的**一对多依赖**，当一个对象改变状态，它的所有依赖者都会收到通知并自动更新。观察者模式有被观察者推送和观察者拉取两种方式
2. 设计原则：
    1. 为交互对象之间的松耦合设计而努力，将对象之间的相互依赖降到最低。
3. 功效：
    1. 观察者可以随时注册或注销自己的观察者角色
    2. 被观察者只需要关注消息的变更与发布。不用关心观察者有哪些

# 装饰者模式（decorator pattern）
1. 概述：在不改变原类文件和不使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。
2. 设计原则：类应该对扩展开放，对修改关闭
    1. 允许类容易扩展，在不修改现在代码的情况下，可搭配新的行为。
    2. 遵循开放-关闭原则，通常会引入新的抽象层次，增加代码复杂程度。需要把精力放在最有可能改变的地方，然后应用开闭原则。
3. 缺点：有大量小类，可能造成API调用的困扰
4. 功效：在不改变原类文件和不使用继承的情况下，动态地扩展一个对象的功能。

# 工厂方法模式（factory method pattern）
1. 概述：定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类中。
2. 设计原则：封装变化、松耦合。
3. 功效：便于管理对象的创建，将产品的“实现”从“使用”中解耦。

# 抽象工厂模式（abstract factory pattern）
1. 概述：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。根据里氏替换原则，任何接受父类型的地方，都应当能够接受子类型。因此，实际上系统所需要的，仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例。
2. 设计原则：依赖抽象，不依赖于具体。（依赖倒置）
3. 功效：
    1. 分离了具体的类
    2. 使得易于交换产品系列
    3. 有利于产品的一致性
    
# 单例模式（singleton pattern）
1. 概述：确保一个类只有一个实例，并提供全局访问点

# 命令模式（command patteran）
1. 概述：将“请求”封装成对象，以便使用不同的请求、队列或日志来参数化其他对象，命令模式也支持可撤销的操作
2. 应用场景：当需要将发出请求的对象与执行请求的对象解耦的时候用命令模式。
